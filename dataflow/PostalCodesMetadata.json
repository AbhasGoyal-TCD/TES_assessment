{
	"name": "PostalCodesMetadata",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "PostalCodesExcel",
						"type": "DatasetReference"
					},
					"name": "ReadSource"
				},
				{
					"dataset": {
						"referenceName": "PostalCodesSQL",
						"type": "DatasetReference"
					},
					"name": "ReadSQL"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "PostalCodesSQL",
						"type": "DatasetReference"
					},
					"name": "sink1"
				}
			],
			"transformations": [
				{
					"name": "CheckforDuplicates"
				},
				{
					"name": "MergeSources"
				},
				{
					"name": "MarkUpdates"
				},
				{
					"name": "TransformType"
				},
				{
					"name": "FilterExistingRows"
				}
			],
			"scriptLines": [
				"source(output(",
				"          postal_code as string,",
				"          state as string,",
				"          region as string,",
				"          country as string",
				"     ),",
				"     allowSchemaDrift: false,",
				"     validateSchema: true,",
				"     ignoreNoFilesFound: false,",
				"     enableCdc: true,",
				"     mode: 'read',",
				"     skipInitialLoad: false) ~> ReadSource",
				"source(output(",
				"          Postal_Code as integer,",
				"          State as string,",
				"          Region as string,",
				"          Country_Region as string,",
				"          Country as string",
				"     ),",
				"     allowSchemaDrift: false,",
				"     validateSchema: true,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     format: 'table') ~> ReadSQL",
				"ReadSource aggregate(groupBy(postal_code,",
				"          state,",
				"          region,",
				"          country),",
				"     Dummy = sum(1)) ~> CheckforDuplicates",
				"TransformType, ReadSQL join(TransformType@postal_code == ReadSQL@Postal_Code,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> MergeSources",
				"FilterExistingRows@Retain alterRow(updateIf(FilterExistingRows@Retain@postal_code != FilterExistingRows@Retain@Postal_Code || FilterExistingRows@Retain@state != FilterExistingRows@Retain@State || FilterExistingRows@Retain@region != FilterExistingRows@Retain@Region || FilterExistingRows@Retain@country != FilterExistingRows@Retain@Country || FilterExistingRows@Retain@Country_Region != FilterExistingRows@Retain@Country_Region)) ~> MarkUpdates",
				"CheckforDuplicates derive(postal_code = toInteger(postal_code),",
				"          Country_Region = case(region == 'East', 'Eastern US', case(region == 'West', 'Western US', case(region == 'Central', 'Central US', case(region == 'South', 'Southern US', ''))))) ~> TransformType",
				"MergeSources split((TransformType@postal_code != ReadSQL@Postal_Code || CheckforDuplicates@state != ReadSQL@State || CheckforDuplicates@region != ReadSQL@Region || CheckforDuplicates@country != ReadSQL@Country || TransformType@Country_Region != ReadSQL@Country_Region) || (isNull(ReadSQL@Postal_Code) && isNull(ReadSQL@State) && isNull(ReadSQL@Region) && isNull(ReadSQL@Country)),",
				"     disjoint: false) ~> FilterExistingRows@(Retain, Ignore)",
				"MarkUpdates sink(allowSchemaDrift: false,",
				"     validateSchema: true,",
				"     input(",
				"          Postal_Code as integer,",
				"          State as string,",
				"          Region as string,",
				"          Country_Region as string,",
				"          Country as string",
				"     ),",
				"     deletable:false,",
				"     insertable:true,",
				"     updateable:true,",
				"     upsertable:false,",
				"     keys:['postal_code'],",
				"     format: 'table',",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
			]
		}
	}
}